
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>分布式系统 | 踢踢vip的个人博客</title>
<meta name="description" content="温故而知新">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2018yuli.github.io//favicon.ico?v=1585983678090">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2018yuli.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2018yuli.github.io/">
        <img class="avatar" src="https://2018yuli.github.io//images/avatar.png?v=1585983678090" alt="" width="32px" height="32px">
      </a>
      <a href="https://2018yuli.github.io/">
        <h1 class="site-title">踢踢vip的个人博客</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/building" class="menu purple-link">
            构想
          </a>
        
      
        
          <a href="/economics" class="menu purple-link">
            经济
          </a>
        
      
        
          <a href="/games" class="menu purple-link">
            游戏
          </a>
        
      
        
          <a href="/projects" class="menu purple-link">
            项目
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2018yuli.github.io//post-images/ce-shi.jpg')">
            </div>
          
          <h2 class="post-title">分布式系统</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-04-04</span>
            
          </div>
          <div class="post-content">
            <h1 id="分布式系统">分布式系统</h1>
<h2 id="简介">简介</h2>
<h4 id="定义">定义：</h4>
<blockquote>
<p>分布式系统是一系列的，通过网络连接的自动运算设备。这些设备上部署了分布式系统软件。</p>
</blockquote>
<p><img src="http://47.101.11.182/upload/2020/2/WhatIsDistributionSystem-40b681edd40c4aefacd55d00de45d265.png" alt="WhatIsDistributionSystem"></p>
<h4 id="特性挑战">特性（挑战）</h4>
<ol>
<li>资源共享 <strong>Resource Sharing</strong>
共享硬件，软件，数据等分布式系统的所有资源</li>
<li>开放性 <strong>Openness</strong>
关注分布式系统的可扩展性 extention 和 可替换性 improvement</li>
<li>并发性一致性 <strong>Concurrency</strong></li>
<li>可伸缩性 <strong>Scalibility</strong>
规模具备可伸缩性</li>
<li>容错性 <strong>Fault tolerance</strong>
系统的可靠性 reliability，当系统的软硬件故障时系统可继续提供服务。</li>
<li>透明性 <strong>Transparency</strong>
对最终用户、应用程序隐藏分布式系统的复杂性</li>
</ol>
<h4 id="应用领域">应用领域</h4>
<ol>
<li>财务和电子商务相关，栗如：亚马逊，e-bay，电子银行</li>
<li>信息系统，栗如：搜索引擎，维基百科，社交网站</li>
<li>创造性产业和休闲，栗如：在线游戏，音乐，youtube</li>
<li>健康管理，栗如：在线接诊，健康信息学</li>
<li>教育，栗如：e-leaning,</li>
<li>运输和物流，栗如：GPS，google Maps</li>
<li>科学相关行业，栗如：</li>
<li>环境管理，栗如：Senso tech，地震预测</li>
</ol>
<h4 id="实例">实例</h4>
<p>有多个分支机构的国有银行
<img src="http://47.101.11.182/upload/2020/3/DSeg-94be077761d0449993b25181cd69becf.png" alt="DSeg"></p>
<h4 id="系统基本需求">系统基本需求</h4>
<ol>
<li>安全性和可靠性</li>
<li>副本集数据的一致性</li>
<li>并发事务支持</li>
<li>容错性</li>
</ol>
<h4 id="体系结构">体系结构</h4>
<ol>
<li>
<p>基于共享内存体系结构
<code>高耦合系统</code> <code>编码更容易</code></p>
</li>
<li>
<p>基于分布式存储体系结构
<code>低耦合系统</code></p>
</li>
</ol>
<p><img src="http://47.101.11.182/upload/2020/3/DSArchitecture-23cfbfbddad84366adcc25a4de87a273.png" alt="DSArchitecture"></p>
<h2 id="分布式系统的优劣">分布式系统的优劣</h2>
<h4 id="优势">优势</h4>
<ul>
<li>固有的分布式应用软件</li>
<li>跨地理分布的用户间的信息共享</li>
<li>资源共享</li>
<li>更好的性价比</li>
<li>缩短响应时间并提高吞吐量</li>
<li>更高的可靠性和针对组件故障的可用性</li>
<li>可扩展性和规模可伸缩性（incremental growth）</li>
<li>更好的灵活性</li>
</ul>
<h4 id="劣势">劣势</h4>
<ul>
<li>当前不存在相关软件</li>
<li>由于可以轻易的访问所有数据，带来了安全性问题</li>
<li>网络状况可能导致数据传输混乱</li>
</ul>
<h4 id="设计一个分布式系统首先需要考虑哪些问题">设计一个分布式系统首先需要考虑哪些问题</h4>
<ol>
<li>怎么实现透明性（对最终用户、应用程序隐藏分布式系统的复杂性）</li>
<li>怎么实现灵活性</li>
<li>怎么实现可靠性</li>
<li>怎么提高性能</li>
<li>怎么实现可伸缩性</li>
<li>怎么提高安全性</li>
</ol>
<h2 id="ds-中的模型">DS 中的模型</h2>
<p>分布式计算中设计到两种类型的模型：基本模型和体系结构模型</p>
<h4 id="数据模型funcamental-model">数据模型（funcamental model）</h4>
<p>数据模型指的是：只有基本的属性的模型（Based on some fundamental properties）
栗如：</p>
<ul>
<li>交互模型（Interaction model）</li>
<li>错误模型（failure model）</li>
<li>认证模型（security model）</li>
</ul>
<h4 id="架构模型architectural-model">架构模型（architectural model）</h4>
<p>架构模型指的是：一种架构方式：（Baesed on architectural style）
栗如：</p>
<ul>
<li>客户机-服务器模型 （client-server model）</li>
<li>对等模型: （peer-to-peer model）</li>
</ul>
<p>architectural Model Deals with organization of component across the network of computers and their inter relationship
架构模型：架构模型处理跨计算机网络的，<strong>组件</strong>之间的组织方式及其相互关系</p>
<ul>
<li>客户机-服务器模型 （client-server model）
<ul>
<li>架构模型中最重要的，应用最广泛的模型（Master~Slave）</li>
<li>客户机和服务器角色可以自由分配，并且是可变更的
<img src="http://47.101.11.182/upload/2020/3/ClientServer-585cc6d8549c43afaa734db4de14fddd.png" alt="ClientServer"></li>
</ul>
</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/3/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8%E5%8D%95%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8-0548efafa79c46fd8e4ced48eb5914cd.png" alt="客户端调用单个服务器"></p>
<ul>
<li>
<p>对等模型: （peer-to-peer model）
与客户机-服务器不同，p-2-p 模式不区分客户机与服务器。相反，每个节点都可以是客户机或服务器，这取决于节点当前需要执行请求还是提供服务
每个节点都被视为<strong>对等节点</strong>
<img src="http://47.101.11.182/upload/2020/3/%E5%AF%B9%E7%AD%89%E6%A8%A1%E5%9E%8B-542c92eb002347a997757f745c97ab76.png" alt="对等模型"></p>
</li>
<li>
<p>根据应用需要构建交互模式</p>
</li>
<li>
<p>为了分配负载，并提供高可靠性（个别计算断开时提供弹性），每个共享对象将被多个节点<strong>冗余</strong>。</p>
</li>
<li>
<p>组建和恢复单个节点，比客户机-服务器体系结构更复杂。
<img src="http://47.101.11.182/upload/2020/3/p2p-6d5d682da0a448e68d51cf37c0537b94.png" alt="p2p"></p>
</li>
</ul>
<h4 id="基本模型">基本模型</h4>
<h5 id="交互模型interaction-model">交互模型（Interaction model）</h5>
<ul>
<li>在进程内交互</li>
<li>进程间传递交互消息，包括
<ul>
<li>进程间通信（信息流）</li>
<li>进程间协作（同步有序的活动）</li>
</ul>
</li>
</ul>
<p>DS系统通过交互模型通信一定会有延迟。</p>
<ul>
<li>影响通信性能的因素（信道 communication channel）
<ul>
<li>本身延迟 Latency (message, network, system)</li>
<li>带宽 Bandwidth</li>
<li>不稳定性 Jitter</li>
</ul>
</li>
</ul>
<p>交互模型的两种形式</p>
<ul>
<li>DS 同步交互
<ul>
<li>进程执行在一个最短、最长时间界限内</li>
<li>在已知时间内接收消息</li>
<li>已知本地时钟衰减率</li>
</ul>
</li>
<li>DS 异步交互
<ul>
<li>DS没有进程执行速度限制</li>
<li>DS没有消息传递延迟限制</li>
<li>DS没有时钟偏差限制</li>
</ul>
</li>
</ul>
<h5 id="错误模型failure-model">错误模型（failure model）</h5>
<ul>
<li>故障模型定义并分类故障</li>
<li>了解系统中可能发生的故障类型很重要
<ul>
<li>故障停机 (fail stop)：一个进程停止并保持停止。其他进程可以检测到该进程已失败</li>
<li>崩溃 (crash)：一个进程停止并保持停止。其他进程可能无法检测此状态</li>
<li>遗漏 (omission)：传出消息缓冲区中新增的消息永远不会同步到另一端的传入消息缓冲区</li>
<li>乱 (arbitrary)：进程或通道出现行为混乱，它可以在任意时间发送或传输任意消息，或提交任务。进程可能会停止或采取不正确的步骤。</li>
<li>定时故障 (timing failure)：时钟偏差超过允许范围</li>
</ul>
</li>
</ul>
<h5 id="认证模型security-model">认证模型（security model）</h5>
<p>系统设计师需要注意以下几个潜在的威胁</p>
<ul>
<li>对进程的威胁 (threats to processes) :攻击者使用假身份发送请求或响应</li>
<li>对通信渠道的威胁 (threats to communication channels) : 攻击者可以监听消息并保存</li>
<li>拒绝服务 (denial of service) :攻击者可以通过发出过多请求来过载服务器</li>
</ul>
<p>加密和身份验证通常用于提供安全性</p>
<h2 id="分布式系统基础概念">分布式系统基础概念</h2>
<ul>
<li>网络操作系统 (network operating system NOS)</li>
<li>分布式操作系统 （Distributed operating system Dos）</li>
<li>中间件操作系统 （Middleware os Mos）</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/3/dsConcept-82f92ae4eb524086aaddfccc39e9f9e6.png" alt="dsConcept"></p>
<h4 id="网络操作系统-nos">网络操作系统 Nos</h4>
<ul>
<li>利用高速网络连接的工作站网络构建</li>
<li>每个工作站都是彼此独立的计算机，有自己的操作系统、内存和其他资源，如硬盘、操作系统甚至数据库</li>
<li>Nos遵循松散耦合的架构模式，本地机器本身提供的服务可以独立使用</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/3/DsNos-22f2e766080842ed96b5cf853c6aac73.png" alt="DsNos"></p>
<ul>
<li>优势
<ul>
<li>它具有可伸缩性，支持大量的资源</li>
</ul>
</li>
<li>劣势
<ul>
<li>它不能在单个节点上提供完整的视图</li>
</ul>
</li>
</ul>
<h4 id="分布式操作系统-dos">分布式操作系统 Dos</h4>
<p>多进程和多台计算机的不同</p>
<ul>
<li>多进程：使用各自的系统服务管理系统中的资源，通过系统调用进行通信</li>
<li>多台计算机：分布式操作系统在每台计算机上都有一个独立的操作系统，进行通信</li>
</ul>
<p>Dos 使分布式系统的行为类似于虚拟单处理器，即使系统在一组计算机上运行
Dos 特性：</p>
<ul>
<li>允许进程间通信</li>
<li>统一进程管理机制</li>
<li>统一文件系统可见性</li>
<li>相同的内核实现</li>
<li>远程机器的本地控制</li>
<li>统一调度问题</li>
</ul>
<p>Dos 使用消息传递接口（MPI）与所有计算机通信
Dos 遵循高度耦合的架构模式
Dos 使用诸如queue之类的分发系统来避免发送方和接收方计算机之间的消息丢失（栗如：自动化银行系统、铁路预留系统等）</p>
<p>Dos 的劣势</p>
<ul>
<li>它有一个可伸缩性问题，因为它只支持有限数量的具有共享资源的独立计算机</li>
<li>在执行消息之前，需要定义消息传递语义</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/3/Dos-957ed8bb50284c8d8cfaebca8aedbc63.png" alt="Dos"></p>
<h4 id="分布式中间件">分布式中间件</h4>
<ul>
<li>因为 Dos 缺乏可伸缩性，Nos 缺乏全局的聚合视图。所以，在 Dos 和 Nos 中间，产生了一个新的层 Mos.</li>
<li>它为本地应用程序提供了一组公共服务，为远程应用程序提供了一组独立的服务</li>
<li>它支持异构性，因此它支持多种语言和操作系统，用户可以在任何平台下使用任何受支持的语言自由编写应用程序</li>
<li>它提供以组服务：比如按名称定位对象或接口、查找对象位置、监测服务状态、处理协议信息、同步、并发和安全性等。</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/3/Mos-56721278b27a410486e22e572c40fc50.png" alt="Mos"></p>
<h2 id="分布式系统间的通信">分布式系统间的通信</h2>
<h4 id="通信种类">通信种类</h4>
<ol>
<li>面向消息的通信</li>
<li>远程过程调用（RPC）</li>
<li>远程方法调用（RMI）
<ol>
<li>RMI本质上是RPC，但特定于远程obj</li>
</ol>
</li>
<li>面向流的通信</li>
</ol>
<h4 id="消息传递">消息传递</h4>
<p>将数据集从发送方传输到接收方</p>
<h4 id="通信协议通信规则">通信协议（通信规则）</h4>
<p>协议可以是面向连接的或无连接的
<img src="http://47.101.11.182/upload/2020/3/7layers-67ff9c5297904631af57353bd49fd6da.png" alt="7layers"></p>
<p>分层协议
<img src="http://47.101.11.182/upload/2020/3/layers-4065c225dfdd4c29877e80fcbf321828.png" alt="layers"></p>
<p>消息传递过程
<img src="http://47.101.11.182/upload/2020/3/Dslayers-6e317b2d29c54ee1b812ffed40de5b7f.png" alt="Dslayers"></p>
<h3 id="远程过程调用-rpc">远程过程调用 RPC</h3>
<ul>
<li>RPC是一种协议，一个程序可以使用它访问网络上另一台计算机上的服务，而不必关注网络方面的详细信息</li>
<li>过程调用也称为函数调用或子程序调用</li>
<li>RPC 使用 客户-服务端 模式</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/3/rpc2-20f3aa1ec4c84d03b77ff0281977aeb0.png" alt="rpc2"></p>
<p><img src="http://47.101.11.182/upload/2020/3/rpc-d159a2335680413f95455ef5c43434ac.jpg" alt="rpc"></p>
<ul>
<li>RPC 服务主要包括5个元素
<ul>
<li>客户端</li>
<li>客户端 stub（stub：用于将调用转换为消息）</li>
<li>RPC 运行时（RPC通信包/network）</li>
<li>服务端 stub</li>
<li>服务端</li>
</ul>
</li>
<li>客户端
<ul>
<li>启动RPC的用户进程</li>
<li>客户端仅负责调用 stub 中相应过程</li>
</ul>
</li>
<li>客户端 stub
<ul>
<li>在收到请求时，它会将打包请求成一个消息，并要求RPC运行时发送该消息</li>
<li>在收到结果后，它会将结果解包并传递给客户端</li>
</ul>
</li>
<li>RPC 运行时
<ul>
<li>它处理客户端到服务端之间的消息传输</li>
</ul>
</li>
<li>服务端 stub
<ul>
<li>它解包一个调用请求并调用服务器中的相应的过程</li>
<li>在接收到结果时，会启动一个过程执行打包，并请求RPC运行时发送该结果</li>
</ul>
</li>
<li>服务端
<ul>
<li>它执行相应的过程并返回结果给服务器stub</li>
</ul>
</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/3/rpc3-33b92e9b1ca94cecb8b31e1063eff88f.png" alt="rpc3"></p>
<ul>
<li>RPC 服务的调用过程
<ul>
<li>客户端过程以普通方式调用客户端存根</li>
<li>客户端存根生成消息，调用本地操作系统</li>
<li>客户端操作系统向远程操作系统发送消息</li>
<li>远程操作系统向服务器存根发送消息</li>
<li>服务器存根解包参数，调用服务器</li>
<li>服务器将其打包到消息中，调用本地操作系统</li>
<li>服务器操作系统向客户端操作系统发送消息</li>
<li>客户端操作系统向客户端存根发送消息</li>
<li>存根解包结果，返回客户端</li>
</ul>
</li>
</ul>
<h5 id="rpc-栗子">RPC 栗子</h5>
<p><img src="http://47.101.11.182/upload/2020/3/rpc4-57acdd7e1c6e42e08eb0d2e69a7a89e6.png" alt="rpc4"></p>
<h5 id="远程过程调用面临的问题">远程过程调用面临的问题</h5>
<h6 id="rpc-协议选择问题">RPC 协议选择问题</h6>
<ul>
<li>第一个问题是RPC协议的选择
<ul>
<li>面向连接的协议
<ul>
<li>客户端被绑定到服务器，并在其间建立连接</li>
<li>优点：通信变得更容易</li>
<li>缺点：尤其是在局域网上，性能会下降</li>
</ul>
</li>
<li>无连接的协议
<ul>
<li>IP和UDP易于使用，并且很适合现有的UNIX系统和internet网络，但缺点是性能</li>
</ul>
</li>
</ul>
</li>
<li>数据包和消息长度是另一个问题</li>
<li>RPC有很大的固定开销，与发送的数据量无关</li>
<li>因此，在一个 64k 的 RPC 中读取 64k 文件比在 64 个 1k 的 RPC 中读取更有效</li>
<li>因此，重要的是，协议和网络应允许大型传输</li>
<li>一些RPC系统对传输大小由限制</li>
<li>此外，许多网络无法处理大数据包。因此，一个RPC将不得不在多个数据包上被拆分，从而导致额外的开销
<ul>
<li>Stop and wait</li>
<li>Blast protocal</li>
</ul>
</li>
</ul>
<h5 id="rpc-的优势">RPC 的优势</h5>
<ul>
<li>RPC支持面向过程和面向线程的模型</li>
<li>RPC的内部消息传递机制对用户是隐藏的</li>
<li>在RPC中，重新编写和重新开发代码的工作量是最小的</li>
<li>RPC可以在分布式环境和本地环境中使用</li>
<li>RPC省略了许多协议层以提高性能</li>
</ul>
<h5 id="rpc-的劣势">RPC 的劣势</h5>
<ul>
<li>RPC 是一个可以以不同方式实现的概念。没有统一的标准</li>
<li>RPC 只关心交互，对于硬件架构没有灵活性（网络无法处理大数据包）</li>
<li>由于 RPC，成本增加了</li>
</ul>
<h3 id="远程方法调用-rmi">远程方法调用 RMI</h3>
<ul>
<li>RMI 是一个 API ，它提供了用 java 创建分布式应用程序的机制</li>
<li>它允许一个对象调用在另一个JVM中运行的对象的方法</li>
<li>RMI使用两个对象stub和skeleton在应用程序之间提供远程通信</li>
</ul>
<h5 id="rmi-体系结构">RMI 体系结构</h5>
<p>rmi系统的体系结构由三层组成</p>
<ul>
<li>stub / skeleton 层</li>
<li>远程引用层</li>
<li>传输层</li>
</ul>
<p>RMI 体系架构
<img src="http://47.101.11.182/upload/2020/4/RMI-865cd8bf7a3a482fae734a24ac95de3c.png" alt="RMI"></p>
<h5 id="stub-和-skeleton">Stub 和 Skeleton</h5>
<p>RMI使用stub和skeleton对象与远程对象通信
远程对象指的是一种对象：它可以从另一个 JVM 调用对象上的方法</p>
<ul>
<li>Stub
<ul>
<li>它是一个对象，充当客户端的网关。所有传出的请求都通过它进行路由</li>
<li>它驻留在客户端，表示远程对象</li>
<li>当调用stub对象上的方法时，它会
<ul>
<li>它启动与JVM的连接</li>
<li>它将参数写入并发送（收集）到远程虚拟机（JVM）</li>
<li>它等待结果</li>
<li>它读取（解编）返回值和异常</li>
<li>最后，将值返回给调用方</li>
</ul>
</li>
</ul>
</li>
<li>Skeleton
<ul>
<li>它是一个对象，充当对象服务器端的网关</li>
<li>所有传入的请求都通过它进行路由</li>
<li>当skeleton接收到传入的请求时，它将执行以下任务
<ul>
<li>它读取远程对象的参数</li>
<li>它调用实际远程对象上的方法</li>
<li>它将结果发送（封送）给调用者</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/4/RMI2-52dc3428900b457c97617d171e32bf68.png" alt="RMI2"></p>
<h5 id="rmi应用程序的执行过程">RMI应用程序的执行过程</h5>
<ol>
<li>当客户端调用远程对象时，它被 stub 接收，stub 最终将请求传递给远程引用层（RRL）</li>
<li>当客户端 RRL 接收到请求时，它将调用 invoke 远程对象的 remoteRef 方法，将请求传递到服务器端的RRL</li>
<li>当服务器端的RRL将请求传递给 Skeleton（服务器上的代理）时，Skeleton 最终调用服务器上所需的对象</li>
<li>结果会一直传递回客户端</li>
</ol>
<h5 id="java-rmi-栗子">JAVA RMI 栗子</h5>
<p>编写RMI程序的步骤</p>
<ul>
<li>创建远程对象接口</li>
<li>提供远程接口的实现</li>
<li>编译实现类并使用 RMI tool 创建 Stub 和 Skeleton 对象</li>
<li>使用RMI注册工具启动服务注册服务</li>
<li>创建并启动服务端应用程序</li>
<li>创建并启动客户端应用程序</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/4/RMI3-b7fa5cca99d544ac910d96730384559d.png" alt="RMI3"></p>
<pre><code class="language-java">import java.rmi.*;
public interface Adder extends Remote {
  public int add (int x, int y) throws Remote Exceptions;
}
</code></pre>
<pre><code class="language-java">import java.rmi.*;
import java.rmi.Server.*;

public class AdderRemote Extends UniCastRemoteObject implements Adder {
  AddRemote() throws RemoteException {Super();}

  public int add (int x, int y) {
	return (x + y);
  }
}
</code></pre>
<pre><code class="language-bash">rmic AdderRemote;
</code></pre>
<pre><code class="language-bash">rmiregistry 8000
</code></pre>
<h5 id="rmi-的目的">RMI 的目的</h5>
<ol>
<li>最小化应用程序的复杂性</li>
<li>类型安全</li>
<li>分布式垃圾收集</li>
<li>最小化使用本地和远程对象之间的差异</li>
</ol>
<h2 id="消息传递模型">消息传递模型</h2>
<ul>
<li>时序模型：分布式消息传递系统的形式化模型有两个时序模型:同步/异步</li>
<li>通信信道：在信息传递系统中，处理器通过一个通信信道发送或接收信息进行通信。</li>
<li>拓扑结构：通道提供的连接模式描述了消息的拓扑结构。</li>
<li>基于网络的 信道采集</li>
</ul>
<h4 id="消息传递模型算法">消息传递模型算法</h4>
<p>让我们考虑一个由n个进程的消息传递模型</p>
<ol>
<li>n 个进程 p0, p1, ... pn-1</li>
<li>双向点对点通道</li>
<li>每个进程都使用标签 1， 2， 3， ... 来标识它的事件通道，所以进程可能不知道通道的另一端是谁 （如下图：）</li>
</ol>
<p><img src="http://47.101.11.182/upload/2020/4/MsgPassing-c430cb9ac7974b4ab5a5359e2b32a742.png" alt="MsgPassing"></p>
<h4 id="进程和通道模型">进程和通道模型</h4>
<ol>
<li>进程是一个状态机，包括
<ul>
<li>进程的本地状态</li>
<li>信道建模机制</li>
</ul>
</li>
<li>从进程pi到进程pj的通道由两部分组成
<ul>
<li>pi 的 outbuffer：连接到物理通道</li>
<li>pj 的 inbuffer：传入消息队列</li>
</ul>
</li>
</ol>
<p><img src="http://47.101.11.182/upload/2020/4/channel-864f95c4d9c5456e97518e666e05d1b2.png" alt="channel"></p>
<h4 id="选举算法">选举算法</h4>
<ul>
<li>许多分布式算法需要一个进程作为协调器</li>
<li>选举算法：选择唯一协调者的技术（领袖选举）</li>
<li>栗子
<ul>
<li>进程失败接管</li>
<li>伯克利主时钟同步挑选算法</li>
</ul>
</li>
<li>选举算法的类型
<ul>
<li>Bully 选举算法</li>
<li>Ring 令牌环算法</li>
</ul>
</li>
</ul>
<h4 id="bully-选举算法">Bully 选举算法</h4>
<ul>
<li>每个进程都有一个唯一的数字 ID</li>
<li>进程知道其他进程的 ID 和地址</li>
<li>通信被认为是可靠的</li>
<li>关键思想：选择 ID 最高的进程</li>
<li>如果进程刚刚从失败中恢复，协调器失败，则它将启动</li>
<li>多个进程可以同时启动选择</li>
<li>n 个进程需要 O(n2) 消息</li>
<li>算法步骤
<ul>
<li>假设进程 P 向协调器发送消息</li>
<li>如果协调器在时间间隔 T 内没有响应，则假定协调器已失败</li>
<li>现在进程 P 向每个优先级更高的进程发送选举消息，一个优先级数字</li>
<li>它等待响应，如果在时间间隔 T 内没有人响应，那么进程 P 选择自己作为协调器</li>
<li>然后它向所有优先级数字低的进程发送一条中选消息。然后被选为他们的新协调器</li>
<li>但是，如果在时间T内，有从任何其他进程 Q 接收到答案
<ul>
<li>进程 P 将再次等待时间间隔 T 。如果从 Q 接收另一条消息，表明它已被选为协调器</li>
<li>如果 Q 在时间间隔 T 内没有响应，则假设它已挂了，并重新启动算法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/4/Bully-1ef11a1aadce4e1d82f7320c2eb6f071.png" alt="Bully"></p>
<h4 id="ring-令牌环算法">Ring 令牌环算法</h4>
<ul>
<li>此算法适用于按（逻辑或物理）环组织的系统</li>
<li>在这个算法中，我们假设进程之间的链接是单向的，并且每个进程只能管理其右边的进程（管理所有右边的进程）</li>
<li>该算法使用的数据结构是活动列表。一个持有系统中所有活动进程的优先级号的列表</li>
<li>算法步骤
<ul>
<li>如果 P1 检测到协调器故障，它将创建一个空的活跃节点列表。它将数字 1 添加到活动列表中，并向右边邻居节点发送选举信息。</li>
<li>如果进程 P2 从左边的进程接收到选举结果消息，它将以3种方式响应
<ul>
<li>如果收到的消息不包含 1，则 p1 将 2 添加到活跃节点列表并转发该消息 (正常传递)</li>
<li>如果这是它收到或发送的第一条选举消息，则P1使用数字1和2创建新的活动列表。然后发送选举信息1，2 （P2 刚从故障中恢复，未参与选举，则重新选举）</li>
<li>如果进程P1接收到自己的选举消息1，那么P1的活动列表现在包含系统中所有活动进程的编号。现在，进程p1检测到优先级最高的数字表单列表，并将其选为新的协调器（选举投票完成）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/4/Ring-271d539893c84beda9e663587a477fa7.png" alt="Ring"></p>
<h2 id="消息传递接口-message-passing-interface-mpi">消息传递接口 (Message Passing Interface MPI)</h2>
<ul>
<li>MPI是为并行应用而设计的规范</li>
<li>MPI的目标是为编写消息传递程序提供一个广泛使用的标准。MPI 的目标
<ul>
<li>实用的 Practical</li>
<li>轻量 Portable</li>
<li>有效率的 efficient</li>
<li>灵活的 flexible</li>
</ul>
</li>
<li>消息传递库规范是
<ul>
<li>消息传递模型</li>
<li>不针对编译器规范</li>
<li>不针对特定产品</li>
</ul>
</li>
<li>使用 MPI 的理由
<ul>
<li>标准化</li>
<li>可移植性</li>
<li>提高效率 performance opportunities</li>
<li>实用 functionality —— 定义了超过115个例程</li>
<li>可用性 —— 有多种实现，包括商用和开源的</li>
</ul>
</li>
<li>通用MPI程序结构
<ol>
<li>包含MPI头文件；</li>
<li>变量声明；初始化MPI环境；</li>
<li>计算以及MPI通信调用；</li>
<li>关闭MPI通信。</li>
</ol>
</li>
<li>MPI 栗子 hello.c</li>
</ul>
<pre><code class="language-c">#include &lt;mpi.h&gt;
#include &lt;stdio.h&gt;

void main(int argc, char *argv[]) {
    int myrank, size;

    MPI_Init(&amp;argc, &amp;argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);
    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);

    printf(&quot;Processor %d of %d: Hello World!\n&quot;, myrank, size);

    MPI_Finalize();
}
</code></pre>
<pre><code class="language-bash">$ mpirun -np 4 ./rank_size
</code></pre>
<pre><code class="language-sh">Processor 0 of 4: Hello World!
Processor 3 of 4: Hello World!
Processor 1 of 4: Hello World!
Processor 2 of 4: Hello World!
</code></pre>
<h2 id="并行虚拟机-pvm-parallel-virtual-machine">并行虚拟机 PVM (Parallel Virtual Machine)</h2>
<ul>
<li>它是一个软件包，允许异构工作站集合（主机连接池）作为单个高性能（虚拟）机并行运行</li>
<li>PVM通过其虚拟机提供了一个简单而有用的分布式操作系统</li>
<li>它在组成虚拟机的所有计算机上都运行守护程序</li>
</ul>
<h4 id="pvm编程模型">PVM编程模型</h4>
<ul>
<li>PVM应用程序由一组协作任务组成，每个任务负责某个问题的部分工作负载</li>
<li>PVM本质上是动态的，PVM 具有强大资源控制能力，可以添加或删除主机
<ul>
<li>负载均衡</li>
<li>核与核之间的任务迁移的算法</li>
<li>容错性</li>
<li>效率</li>
</ul>
</li>
</ul>
<h4 id="pvm-的容错性">PVM 的容错性</h4>
<ul>
<li>PVM支持基本的故障通知方案
<ul>
<li>它不会在崩溃后自动恢复应用程序，但它确实提供简单的通知以允许构建容错应用程序</li>
</ul>
</li>
<li>虚拟机可以动态重新配置</li>
<li>一个 PVM 可以从任何 PVM 从节点故障中恢复，除了 Master 主节点。因为并行计算中 Master 从不崩溃</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/4/PVM-0bb12d1303764080a8a888baa458b8f5.png" alt="PVM"></p>
<h4 id="pvm-和-mpi-的区别">PVM 和 MPI 的区别</h4>
<html>
    <table style="margin-left: auto; margin-right: auto;">
        <tr>
            <td>
                <!--左侧内容-->
                虚拟机概念 <br/>
		简单消息传递 <br/>
		未指定通信拓扑 <br/>
		跨主机架构边界互操作 <br/>
		可移植性优于性能 <br/>
		资源和过程控制 <br/>
		xx容错 robust fault-tolerant <br/>
            </td>
            <td>
                <!--右侧内容-->
                没有这种抽象 <br/>
		丰富的消息支持 <br/>
		支持逻辑通信拓扑 <br/>
		不跨体系结构的互操作 <br/>
		性能优于灵活性 <br/>
		主要关注消息传递 <br/>
		更容易出错 <br/>
            </td>
        </tr>
	<tr>
	    <td>
		<strong> PVM 适用场景 </strong>
	    </td>
	    <td>
		<strong> MPI 适用场景 </strong>
	    </td>
	</tr>
	<tr>
	    <td>
		<!-- PVM -->
		<br/>
		异构集群、资源和过程控制 <br/>
		集群规模和程序执行时间都很大
	    </td>
	    <td>
		<!-- MPI -->
		超级计算机 <br/>
		最高性能 <br/>
		应用程序需要丰富的消息支持
	    </td>
	</tr>
    </table>
</html>
<h2 id="进程与线程">进程与线程</h2>
<h3 id="进程">进程</h3>
<ul>
<li>进程是一个正在执行的程序
<ul>
<li>执行上下文
<ul>
<li>程序计数器（pc）</li>
<li>堆栈指针（SP）</li>
<li>数据寄存器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>进程模型
<img src="http://47.101.11.182/upload/2020/4/Processor-7116292535694dc2af20f0e4a4f763e4.png" alt="Processor"></p>
<ul>
<li>正在操作系统（虚拟）处理器之一上执行的计算机程序的实例</li>
<li>一个进程有一个虚拟地址空间，打开可执行代码的 —— 系统对象的句柄，一个安全上下文，一个唯一标识符，环境变量，一个优先级类，以及最后 一个可执行的线程</li>
</ul>
<h3 id="线程-轻量化进程">线程 (轻量化进程)</h3>
<ul>
<li>线程是进程内的执行路径，线程独立于其他线程执行自己的代码</li>
<li>将自身分割为两个或多个同时运行的任务的一种处理方法</li>
<li>一个线程只维护最小信息，允许多个线程共享一个 cpu 的最小信息</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/4/Thread-b4fb1cc7dd314fefac9d29a5dd529ad3.png" alt="Thread"></p>
<h3 id="线程与进程">线程与进程</h3>
<ul>
<li>进程：资源、权限（privileges）等的最小调度单位</li>
<li>线程：最小执行单位-PC、SP、寄存器</li>
<li>每个进程可以有多个线程</li>
<li>每个线程隶属于一个进程</li>
<li>进程
<ul>
<li>进程间通信代价高昂：需要上下文切换</li>
<li>安全：一个进程不能中断另一个进程</li>
</ul>
</li>
</ul>
<p><img src="http://47.101.11.182/upload/2020/4/Process2-e739ea4716c3432d823f757a1d46c49d.png" alt="Process2"></p>
<ul>
<li>线程
<ul>
<li>线程间通信更廉价：可以使用进程内存，可能不需要做内容切换</li>
<li>不安全：一个线程可以写另一个线程使用的内存</li>
</ul>
</li>
</ul>
<h3 id="分布式系统中的线程">分布式系统中的线程</h3>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2018yuli.github.io//post/an-li-easyreport">
              <h3 class="post-title">
                下一篇：安利EasyReport
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">温故而知新</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2018yuli.github.io//atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '15958112786b2823cb4a',
        clientSecret: '1bb80db136d28dbbe80f51baf0cc359862245081',
        repo: '2018yuli.github.io',
        owner: '2018yuli',
        admin: ['2018yuli'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
